/*
 * This source file was generated by the Gradle 'init' task
 */
package com.ldtteam.tableau.common;

import com.ldtteam.tableau.common.extensions.ProjectExtension;
import com.ldtteam.tableau.common.extensions.VersioningExtension;
import com.ldtteam.tableau.scripting.extensions.TableauScriptingExtension;
import com.ldtteam.tableau.utilities.extensions.UtilityFunctions;
import org.gradle.api.Project;
import org.gradle.api.Plugin;
import org.gradle.api.file.DuplicatesStrategy;
import org.gradle.api.problems.Problems;
import org.gradle.api.provider.Provider;
import org.gradle.api.tasks.Copy;
import org.gradle.api.tasks.bundling.Jar;
import org.gradle.api.tasks.javadoc.Javadoc;
import org.gradle.external.javadoc.StandardJavadocDocletOptions;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;
import java.util.Objects;

/**
 * The common project plugin.
 * <p>
 * This plugin is applied to all projects and configures the project with the common settings.
 */
@SuppressWarnings("UnstableApiUsage")
public class CommonProjectPlugin implements Plugin<Project> {


    private final Problems problems;

    /**
     * Creates a new plugin instance.
     *
     * @param problems The problems gradle subsystem to report problems to if found.
     */
    @Inject
    public CommonProjectPlugin(Problems problems) {
        this.problems = problems;
    }

    @Override
    public void apply(@NotNull Project target) {
        //Register all base plugins.
        target.getPlugins().apply("java-library");
        target.getPlugins().apply("jacoco");
        target.getPlugins().apply("idea");
        target.getPlugins().apply("eclipse");

        //The DSL Extension.
        TableauScriptingExtension.register(target, ProjectExtension.EXTENSION_NAME, ProjectExtension.class, target);

        //Configure processing.
        configureVersioning(target);
        configureRepositories(target);

        //Set global duplication strategy
        target.getTasks().withType(Copy.class).configureEach(task -> task.setDuplicatesStrategy(DuplicatesStrategy.EXCLUDE));

        //Deal with API javadoc management
        target.getTasks()
                .withType(Javadoc.class)
                .matching(task -> task.getName().contains("api"))
                .configureEach(task -> ((StandardJavadocDocletOptions) task.getOptions()).addStringOption("Xdoclint:none", "-quiet"));

        //Set jar duplication strategies
        target.getTasks().withType(Jar.class).configureEach(jar -> jar.setDuplicatesStrategy(DuplicatesStrategy.EXCLUDE));
    }

    /**
     * Configures all repositories for the project.
     *
     * @param target The target project.
     */
    private void configureRepositories(@NotNull Project target) {
        target.getRepositories().mavenLocal();
        target.getRepositories().mavenCentral();
        target.getRepositories().flatDir(dir -> {
            dir.dirs("libs");
            dir.setName("Local Libraries");
        });
    }

    /**
     * Configures the versioning for the project.
     * <p>
     * This will set the version of the project to the version of the mod.
     * If the minecraft based versioning is enabled, the version will be set to the minecraft based version.
     * If the minecraft based versioning is disabled, the version will be set to the version of the mod.
     *
     * @param target The target project.
     */
    private void configureVersioning(@NotNull Project target) {
        final VersioningExtension versioning = TableauScriptingExtension.register(target, VersioningExtension.EXTENSION_NAME, VersioningExtension.class, target);

        //Default mod version string build from the configured version and suffix.
        final Provider<String> versionString = versioning.getProject().getVersion().zip(versioning.getProject().getSuffix(), (version, suffix) -> {
            if (suffix.trim().isEmpty()) {
                return version;
            }
            return version + "-" + suffix;
        });

        //Minecraft based versioning provider.
        final Provider<String> minecraftBasedVersion = versionString.flatMap(version ->
                versioning.getMinecraft().getMinecraftVersion().flatMap(minecraftVersion ->
                        versioning.getMinecraft().getSourceVersionName().flatMap(sourceVersionName ->
                                versioning.getMinecraft().getSourceVersionElementIndex().flatMap(sourceVersionIndex ->
                                        versioning.getMinecraft().getMinecraftVersionElementIndex().map(minecraftVersionIndex -> UtilityFunctions.get(target).buildVersionNumberWithOffset(
                                                version,
                                                minecraftVersion,
                                                sourceVersionName,
                                                sourceVersionIndex,
                                                minecraftVersionIndex
                                        ))))));

        //Create a toString() capable object for the project version.
        final ProjectVersion projectVersion = new ProjectVersion(versioning.getMinecraft().getEnabled().zip(versionString, (minecraftBasedVersioningEnabled, version) -> {
            if (minecraftBasedVersioningEnabled) {
                return null;
            }

            return version;
        }).orElse(minecraftBasedVersion));

        //Set the version of the project.
        target.setVersion(projectVersion);

        //Set the group of the project.
        target.setGroup(new ProjectGroup(ProjectExtension.get(target).getGroup()));
    }

    /**
     * A record to store the project version, returning only the project version when {@link Object#toString()} is called.
     */
    @SuppressWarnings("ClassCanBeRecord") //Gradle does not like it.
    public static final class ProjectVersion {
        private final Provider<String> versionProvider;

        /**
         * Creates a new project version provider wrapper.
         *
         * @param versionProvider The provider for the version.
         */
        public ProjectVersion(Provider<String> versionProvider) {
            this.versionProvider = versionProvider;
        }

        @Override
        public String toString() {
            return versionProvider().get();
        }

        /**
         * Gets the provider for the version.
         *
         * @return The version provider.
         */
        public Provider<String> versionProvider() {
            return versionProvider;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) return true;
            if (obj == null || obj.getClass() != this.getClass()) return false;
            var that = (ProjectVersion) obj;
            return Objects.equals(this.versionProvider, that.versionProvider);
        }

        @Override
        public int hashCode() {
            return Objects.hash(versionProvider);
        }

    }

    /**
     * A record to store the project group, returning only the project group when {@link Object#toString()} is called.
     */
    @SuppressWarnings("ClassCanBeRecord") //Gradle does not like it.
    public static final class ProjectGroup {
        private final Provider<String> groupProvider;

        /**
         * Creates a new project group provider wrapper.
         *
         * @param groupProvider The provider for the group.
         */
        public ProjectGroup(Provider<String> groupProvider) {
            this.groupProvider = groupProvider;
        }

        @Override
        public String toString() {
            return groupProvider().get();
        }

        /**
         * Gets the provider for the group.
         *
         * @return The group provider.
         */
        public Provider<String> groupProvider() {
            return groupProvider;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) return true;
            if (obj == null || obj.getClass() != this.getClass()) return false;
            var that = (ProjectGroup) obj;
            return Objects.equals(this.groupProvider, that.groupProvider);
        }

        @Override
        public int hashCode() {
            return Objects.hash(groupProvider);
        }

    }
}
